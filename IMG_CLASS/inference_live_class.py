from flask import Flask, Response, render_template_string, request, jsonify,url_for
from picamera2 import Picamera2
import io
import threading
import time
import numpy as np
from PIL import Image
import tflite_runtime.interpreter as tflite
from queue import Queue , Empty

app = Flask(__name__)

# Global variables
picam2 = None
frame = None
frame_lock = threading.Lock()
is_classifying = False
confidence_threshold = 0.8

model_path = "./models/img_class_model/ei-img_class-transfer-learning-tensorflow-lite-int8-quantized-model.3.lite"
#model_path = "./models/img_class_model/ei-img_class-transfer-learning-tensorflow-lite-float32-model.3.ilte"
labels = ['background', 'cup', 'mouse']
interpreter = None
classification_queue = Queue(maxsize=1)

def initialize_camera():
	
	global picam2
	picam2 = Picamera2()
	config = picam2.create_preview_configuration(main={"size": (320, 240)})
	picam2.configure(config)
	picam2.start()
	time.sleep(2) # Wait for camera to warm up

def get_frame():
	
	global frame
	while True:
		stream = io.BytesIO()
		picam2.capture_file(stream, format='jpeg')
		with frame_lock:
			frame = stream.getvalue()
		time.sleep(0.1) # Capture frames more frequently

def generate_frames():
	
	while True:
		with frame_lock:
			if frame is not None:
				yield (b'--frame\r\n'
						b'Content-Type: image/jpeg\r\n\r\n' + frame + b'\r\n')
		time.sleep(0.1)

def load_model():
	
	global interpreter
	if interpreter is None:
		interpreter = tflite.Interpreter(model_path=model_path)
		interpreter.allocate_tensors()
	return interpreter


def classify_image(img, interpreter):
		
	input_details = interpreter.get_input_details()
	output_details = interpreter.get_output_details()
	
	img = img.resize((input_details[0]['shape'][2], input_details[0]['shape'][1]))
	input_data = np.expand_dims(np.array(img), axis=0).astype(input_details[0]['dtype'])
	
	interpreter.set_tensor(input_details[0]['index'], input_data)
	interpreter.invoke()
	
	predictions = interpreter.get_tensor(output_details[0]['index'])[0]
	
	# Handle output based on type
	output_dtype = output_details[0]['dtype']
	
	if output_dtype in [np.int8, np.uint8]:
		# Dequantize the output
		scale, zero_point = output_details[0]['quantization']
		predictions = (predictions.astype(np.float32) - zero_point) * scale
	return predictions
		
def classification_worker():
	interpreter = load_model()
	while True:
		if is_classifying:
			with frame_lock:
				if frame is not None:
					img = Image.open(io.BytesIO(frame))
				predictions = classify_image(img, interpreter)
				max_prob = np.max(predictions)
				if max_prob >= confidence_threshold:
					label = labels[np.argmax(predictions)]
				else:
					label = 'Uncertain'
				classification_queue.put({'label': label,'probability': float(max_prob)})
			time.sleep(1) # Adjust based on your needs
	
@app.route('/')
def index():
	
	return render_template_string('''
		<!DOCTYPE html>
		<html>
		<head>
			<title>Image Classification</title>
			<script
				src="https://code.jquery.com/jquery-3.6.0.min.js">
			</script>
			<script>
				function startClassification() {
					$.post('/start');
					$('#startBtn').prop('disabled', true);
					$('#stopBtn').prop('disabled', false);	
				}
				
				function stopClassification() {
					$.post('/stop');
					$('#startBtn').prop('disabled', false);
					$('#stopBtn').prop('disabled', true);
				}
				
				function updateConfidence() {
					var confidence = $('#confidence').val();
					$.post('/update_confidence', {confidence: confidence});
				}
				
				function updateClassification() {
					$.get('/get_classification', function(data) {
					$('#classification').text(data.label + ': ' + data.probability.toFixed(2));
					});
				}
				
				$(document).ready(function() {
					setInterval(updateClassification, 1000);
					// Update every 100ms
				});
				
			</script>
			
		</head>
		<body>
			<h1>Image Classification</h1>
			<img src="{{ url_for('video_feed') }}" width="640" height="480" />
			<br>
			<button id="startBtn" onclick="startClassification()">
			Start Classification</button>
			<button id="stopBtn" onclick="stopClassification()" disabled>
			Stop Classification</button>
			<br>
			<label for="confidence">Confidence Threshold:</label>
			<input type="number" id="confidence" name="confidence" min="0"
			max="1" step="0.1" value="0.8" onchange="updateConfidence()">
			<br>
			<div id="classification">Waiting for classification...</div>
		</body>
		</html>
		''')
		
		
@app.route('/video_feed')
def video_feed():
	return Response(generate_frames(),mimetype='multipart/x-mixed-replace; boundary=frame')

@app.route('/start', methods=['POST'])
def start_classification():
	global is_classifying
	is_classifying = True
	return '', 204
	
@app.route('/stop', methods=['POST'])
def stop_classification():
	global is_classifying
	is_classifying = False
	return '', 204
	
@app.route('/update_confidence', methods=['POST'])
def update_confidence():
	global confidence_threshold
	confidence_threshold = float(request.form['confidence'])
	return '', 204
	
@app.route('/get_classification')
def get_classification():
	if not is_classifying:
		return jsonify({'label': 'Not classifying', 'probability': 0})
	try:
		result = classification_queue.get_nowait()
	except Empty:
		result = {'label': 'Processing', 'probability': 0}
	return jsonify(result)
	
if __name__ == '__main__':
	initialize_camera()
	threading.Thread(target=get_frame, daemon=True).start()
	threading.Thread(target=classification_worker, daemon=True).start()
	app.run(host='0.0.0.0', port=5000, threaded=True)
